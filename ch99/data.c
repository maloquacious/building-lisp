#include "lisp.h"
#include <stdarg.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

struct Allocation {
    struct Pair pair;
    int mark: 1;
    struct Allocation *next;
};

struct Allocation *global_allocations = NULL;

Atom cons(Atom car_val, Atom cdr_val) {
    struct Allocation *a;
    Atom p;

    a = malloc(sizeof(struct Allocation));
    a->mark = 0;
    a->next = global_allocations;
    global_allocations = a;

    p.type = AtomType_Pair;
    p.value.pair = &a->pair;

    car(p) = car_val;
    cdr(p) = cdr_val;

    return p;
}

Atom make_int(long x) {
    Atom a;
    a.type = AtomType_Integer;
    a.value.integer = x;
    return a;
}

static Atom sym_table = {AtomType_Nil};

Atom make_sym(const char *s) {
    Atom a, p;

    p = sym_table;
    while (!nilp(p)) {
        a = car(p);
        if (strcmp(a.value.symbol, s) == 0) {
            return a;
        }
        p = cdr(p);
    }

    a.type = AtomType_Symbol;
    a.value.symbol = strdup(s);
    sym_table = cons(a, sym_table);

    return a;
}

Atom make_builtin(Builtin fn) {
    Atom a;
    a.type = AtomType_Builtin;
    a.value.builtin = fn;
    return a;
}

int listp(Atom expr) {
    while (!nilp(expr)) {
        if (expr.type != AtomType_Pair) {
            return 0;
        }
        expr = cdr(expr);
    }
    return 1;
}

Atom copy_list(Atom list) {
    Atom a, p;

    if (nilp(list)) {
        return nil;
    }

    a = cons(car(list), nil);
    p = a;
    list = cdr(list);

    while (!nilp(list)) {
        cdr(p) = cons(car(list), nil);
        p = cdr(p);
        list = cdr(list);
    }

    return a;
}

Atom list_create(int n, ...) {
    va_list ap;
    Atom list = nil;

    va_start(ap, n);
    while (n--) {
        Atom item = va_arg(ap, Atom);
        list = cons(item, list);
    }
    va_end(ap);

    list_reverse(&list);
    return list;
}

Atom list_get(Atom list, int k) {
    while (k--) {
        list = cdr(list);
    }
    return car(list);
}

void list_set(Atom list, int k, Atom value) {
    while (k--) {
        list = cdr(list);
    }
    car(list) = value;
}

void list_reverse(Atom *list) {
    Atom tail = nil;
    while (!nilp(*list)) {
        Atom p = cdr(*list);
        cdr(*list) = tail;
        tail = *list;
        *list = p;
    }
    *list = tail;
}

void gc_mark(Atom root) {
    struct Allocation *a;

    if (!(root.type == AtomType_Pair
          || root.type == AtomType_Closure
          || root.type == AtomType_Macro)) {
        return;
    }

    a = (struct Allocation *)
            ((char *) root.value.pair
             - offsetof(
    struct Allocation, pair));

    if (a->mark) {
        return;
    }

    a->mark = 1;

    gc_mark(car(root));
    gc_mark(cdr(root));
}

void gc() {
    struct Allocation *a, **p;

    gc_mark(sym_table);

    /* Free unmarked allocations */
    p = &global_allocations;
    while (*p != NULL) {
        a = *p;
        if (!a->mark) {
            *p = a->next;
            free(a);
        } else {
            p = &a->next;
        }
    }

    /* Clear marks */
    a = global_allocations;
    while (a != NULL) {
        a->mark = 0;
        a = a->next;
    }
}

